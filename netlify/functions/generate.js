const fetch = require('node-fetch');

// Simple local response generator for when AI models are unavailable
function generateLocalResponse(data) {
  const tone = data.type === 'positive' || data.type === 'lift' ? 'Uplift' : 'Roast';
  const displayName = data.name || 'Someone';
  const userMood = data.mood?.toLowerCase() || 'feeling something';

  const upliftResponses = [
    `ðŸ”¥ ${displayName}, you're absolutely crushing it! Your energy is unstoppable and your vibe is immaculate. Keep shining bright! âœ¨`,
    `ðŸš€ ${displayName}, you're a force of nature! Every challenge makes you stronger. Keep going, you're thriving! ðŸ’ª`,
    `ðŸŒŸ ${displayName}, you're absolutely electric! You turn ordinary moments into magic. Keep being you! ðŸ’«`,
    `âš¡ ${displayName}, you're a diamond in a world of zirconia! Your shine is real, your impact is huge! ðŸ”¥`,
    `ðŸ’Ž ${displayName}, you're the main character in an epic story! Your comeback is going to be legendary. âœ¨`
  ];

  const roastResponses = [
    `ðŸ˜… ${displayName}, the AI is having a moment (probably intimidated by your chaos). Even when tech fails, you're the plot! ðŸŽ­`,
    `ðŸŽª ${displayName}, the servers are being dramatic â€” like you on a Monday. Even the AI can't handle you! ðŸŽ¯`,
    `â° ${displayName}, even our servers needed a nap after hearing your mood. Try again, icon! ðŸš€`,
    `ðŸŽ­ ${displayName}, you're too iconic â€” even the models froze in awe. Try again, scene stealer! ðŸ“–`,
    `ðŸŽª ${displayName}, the AI short-circuited from your personality alone. That's star power! ðŸŽ¯`
  ];

  const responses = tone === 'Uplift' ? upliftResponses : roastResponses;
  return responses[Math.floor(Math.random() * responses.length)];
}

// Fallback responses if something fails
function generateFallbackResponse(data, headers, errorType = 'fallback') {
  const tone = data.type === 'positive' || data.type === 'lift' ? 'Uplift' : 'Roast';
  const title = tone === 'Uplift' ? 'LIFT PROTOCOL ACTIVATED' : 'ZING MODE ENGAGED';
  const displayName = data.name || 'Someone';

  const fallbackMessages = {
    timeout: `${displayName}, the connection is slow. Try again â€” the world needs your vibe!`,
    rate_limit: `${displayName}, too hot to handle! AI servers are rate-limited. Try again shortly.`,
    api_error: `${displayName}, the AI glitched â€” you're just too iconic. Try again in a moment.`,
    parse_error: `Hmm... couldn't understand the response. You're still legendary though, ${displayName}.`,
    empty_response: `Oops! No message came through. Must be your vibe breaking the system.`,
    fallback: `Even when tech fails, ${displayName}, you're the whole show. Try again!`
  };

  const message = fallbackMessages[errorType] || fallbackMessages.fallback;

  return {
    statusCode: 200,
    headers,
    body: JSON.stringify({
      message,
      title,
      source: errorType
    })
  };
}

exports.handler = async function (event, context) {
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Content-Type': 'application/json'
  };

  if (event.httpMethod === 'OPTIONS') return { statusCode: 200, headers, body: '' };
  if (event.httpMethod !== 'POST') return { statusCode: 405, headers, body: JSON.stringify({ error: 'Method Not Allowed' }) };

  let data;
  try {
    data = JSON.parse(event.body || '{}');
  } catch (err) {
    return generateFallbackResponse({ type: 'funny' }, headers, 'parse_error');
  }

  const { name, gender, mood, type, intensity } = data;
  const displayName = name || 'Someone';
  const tone = type === 'positive' || type === 'lift' ? 'Uplift' : 'Roast';
  const userMood = mood?.toLowerCase() || 'unknown mood';
  const level = intensity || 'medium';

  const isHarmful = /suicide|kill myself|cutting|self harm|hurt myself|hurt others|end my life|die|kill someone|take my life/i;
  if (isHarmful.test(userMood)) {
    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        message: `It sounds like you're going through something heavy â€” and that's okay.\n\nðŸŒ https://www.befrienders.org\nðŸ‡ºðŸ‡¸ https://988lifeline.org\nðŸ‡¬ðŸ‡§ https://samaritans.org\n\nTake a breath. You matter. â¤ï¸`,
        title: "Let's take a moment",
        source: 'safety-check'
      })
    };
  }

  const prompt = `
Create a creative, short, emotionally expressive message for ${displayName}${gender ? ` (${gender})` : ''}.
Context: ${mood || 'unknown'} mood, ${level} intensity level.
${tone === 'Uplift'
    ? 'Style: powerful, vivid, affirming, encouraging â€” like a motivational quote.'
    : 'Style: witty, ironic, clever, teasing â€” roast playfully without compliments or flattery.'
}
End with: "ðŸ”¥ Generated by Lift or Zingâ„¢"
Write only the message, no instructions.
`;

  const MODEL_POOL = [
    { model: 'mistralai/mistral-7b-instruct:free', key: process.env.OPENROUTER_KEY_MISTRAL },
    { model: 'sarvamai/sarvam-m:free', key: process.env.OPENROUTER_KEY_SARVAM },
    { model: 'shisa-ai/shisa-v2-llama3.3-70b:free', key: process.env.OPENROUTER_KEY_SHISA },
    { model: 'moonshotai/kimi-vl-a3b-thinking:free', key: process.env.OPENROUTER_KEY_KIMI },
    { model: 'nvidia/llama-3.1-nemotron-ultra-253b-v1:free', key: process.env.OPENROUTER_KEY_NEMO }
  ];

  const rateLimited = new Set();

  for (const { model, key } of MODEL_POOL) {
    if (!key || rateLimited.has(model)) continue;

    try {
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 5000);

      const res = await fetch('https://openrouter.ai/api/v1/chat/completions', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${key}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': 'https://liftorzing.com',
          'X-Title': 'LiftorZing'
        },
        body: JSON.stringify({
          model,
          messages: [{ role: 'user', content: prompt.trim() }],
          max_tokens: 200,
          temperature: 0.9
        }),
        signal: controller.signal
      });

      clearTimeout(timeout);

      if (!res.ok) {
        if (res.status === 429) rateLimited.add(model);
        continue;
      }

      const json = await res.json();
      const message = json?.choices?.[0]?.message?.content?.trim();

      if (message && message.length > 10) {
        return {
          statusCode: 200,
          headers,
          body: JSON.stringify({
            message,
            title: tone === 'Uplift' ? 'LIFT PROTOCOL ACTIVATED' : 'ZING MODE ENGAGED',
            source: model
          })
        };
      }

    } catch (err) {
      console.warn(`${model} error:`, err.name === 'AbortError' ? 'Timeout' : err.message);
    }
  }

  // Hugging Face fallback
  const hfKey = process.env.HUGGINGFACE_API_KEY;
  const hfModels = ['gpt2', 'distilgpt2'];

  if (hfKey) {
    for (const model of hfModels) {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 8000);

        const res = await fetch(`https://api-inference.huggingface.co/models/${model}`, {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${hfKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ inputs: prompt.trim(), parameters: { max_new_tokens: 150 } }),
          signal: controller.signal
        });

        clearTimeout(timeout);

        if (!res.ok) continue;

        const json = await res.json();
        const message = json?.[0]?.generated_text?.trim();

        if (message && message.length > 10) {
          return {
            statusCode: 200,
            headers,
            body: JSON.stringify({
              message,
              title: tone === 'Uplift' ? 'LIFT PROTOCOL ACTIVATED' : 'ZING MODE ENGAGED',
              source: `huggingface-${model}`
            })
          };
        }

      } catch (err) {
        console.warn(`HuggingFace ${model} error:`, err.message);
      }
    }
  }

  // Final local fallback
  const localMessage = generateLocalResponse(data);

  return {
    statusCode: 200,
    headers,
    body: JSON.stringify({
      message: localMessage,
      title: tone === 'Uplift' ? 'LIFT PROTOCOL ACTIVATED' : 'ZING MODE ENGAGED',
      source: 'local-fallback'
    })
  };
};
